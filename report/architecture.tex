Since one requirement of a Proof of Work system is that it minimises differences between a wide variety of devices appearing in the wild we needed to support both desktop and laptops with different operating systems as well as cellphones and tablets.
In order to minimise the development effort and maximise maintainability of the code base, a multi platform solution was sought for the client part of the demo application. 

A web based solution makes the perfect portable application, however the web is not inherently stateful and quite badly imitates an application server which keeps a constantly open socket connection with connected clients. The advent of websockets turn the whole thing around, with the help of DoS nice fellas we were able to write a truly multi-platform PoW client in html and javascript which maintains the generality and plasticity of a natively written socket based application. The javascript implementation for handling th protocol is quite simple:
\jscode[firstline=57, firstnumber=57, lastline=84]{../pow.js}
The solution finding part also need to be present:
\jscode[firstline=26, firstnumber=26, lastline=49]{../pow.js}
To trigger a request to be sent to the server we build the following function which is then registered to the onclick event of a button in the web gui:
\jscode[firstline=100, firstnumber=100, lastline=105]{../pow.js}

For the server side we choose to use Googles novel programming language go(\citeurl{golang}). The real strengths of golang in this context is actually not performance nor simplicity\footnote{But the expressiveness, clarity and performance of go programs is not to be dismissed.} but rather it's standard libraries, which in other contexts may appear immature. Golang actually has standard libraries for both http template generation, web serving as well as websockets. This package makes for an ideal platform for an application that needs to deliver the client application\footnote{HTML, CSS, Javascript and all that magic that make stuff happen in the browser} to potential clients as well as servicing clients requests in the model application reachable through the websocket interface. 

To further ease our programming task, we choose to communicate over the websocket with a single message type which is (de-)serialised (from) to JSON. JSON is natively supported in the Javascript client, and the golang websocket library supports JSON (de-)serialisation which makes for a nice pairing where we have to write absolutely no byte parsing for our protocol.
\gocode[firstline=35, firstnumber=35, lastline=40]{../conn.go}



\begin{tikzpicture}
\tiny
\matrix (m)[matrix of nodes, column  sep=1cm,row  sep=2mm, nodes={draw=none, anchor=center,text depth=0pt} ]{
\textbf{\underline {server}} & & \textbf{client}\\[-4mm]
& & \\
& request for service & \\
$function f_i:=$ $\{N,prob,nil\}$ \hfill \\
problem set $\phi :=  \{f_1\dots f_N\} $ \hfill \\
& send problems & \\
& & solve each $f_i \in \phi$ \\
& & $f_i := \{N,prob,sol\}$ \\
& send solutions & \\
for each $f_i \in f_i$ & & \\
verify $sol \in f_i$ && \\ 
& grant request & \\
};
\draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-3-2.south east)--(m-3-2.south west);
\draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-6-2.south west)--(m-6-2.south east);
\draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-9-2.south east)--(m-9-2.south west);
\draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-12-2.south west)--(m-12-2.south east);
\end{tikzpicture}