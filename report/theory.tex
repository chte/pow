%LINKZÄ http://conferences.sigcomm.org/co-next/2007/papers/studentabstracts/paper46.pdf se 2. THE PROOF-OF-WORK APPROACH
%
%https://www.ideals.illinois.edu/bitstream/handle/2142/17372/TechReport.pdf?sequence=3
%
% Puzzle-based defense mechanisms such as [41, 9, 20, 35, 26] try to correct the imbalance between the cost to the attacker for generating a request and cost to the server for processing a request by demanding a payment, in the form of a puzzle solution, from each client. In a typical puzzle-based scheme, a request must be accompanied by a proof of payment from the client. The payment may be in the form of computation or memory accesses that the client needs to perform to solve the puzzle. Since the amount of resources available to the attacker is limited (even if it is much more than that of the legitimate clients), the attacker will not be able to trivially amplify his attack. There are different kinds of schemes that build on this general principle. Laurie et al. [31] have analyzed proof-of-work schemes in the context of a spam deterrent mechanism and conclude that proof-of-work schemes do not work, because the cost involved for legitimate senders would be too high. However, their economic estimation contains a miscalculation. More importantly, their analysis considers fixed-cost puzzle schemes and does not analyze adaptive proof-of-work schemes proposed by recent DoS counter-measures.

Denial of Service attacks are often possible due to the relative price of a request, for an adversary often a single network packet\cite{gunter}. Puzzle-based proof-of-work limit an attacker's possibilities to impose a high work load on a server from a sole client by increasing the cost of each request. 

The RB-PoW scheme utilises a hash-reversal puzzle very similair to hashcash. The problem definition is a seed $P_i[j]$\footnote{For a precise definition of $P_i[j]$, $i$ and $j$, please see section \ref{text:protonot}}. The client needs to find $S_i[j]$ such that the computed hash $ h = H(S_i[j]||P_i[j])$ holds the property that the leading $d$ (issued difficulty) digits in the hex representation of $h$ are all equal to zero. It is computationally infeasible to find $x$  for a given $h$ such that $ h = \mbox{sha2}(x)$\cite{sha2}, consequently the only way to find $S_i[i]$ is by sequential trial. For $d_l = d + 1 $, only $\frac{1}{16}$ of solutions accepted for difficulty $d$ are accepted. The complexity of finding $S_i[j]$ is thus $O(16^d)$. This is however an amortized complexity, since one can be lucky and find a solution in the first hash test, or be forced to seek nealy the complete solution space. The actual running time is actually geometrically distributed with an expected outcome of $16^d$ trials before finding the solution, but the running time may be improved to approach a normal distribution with the introduction of subpuzzles\cite{subpuzzles}. The reputation based proof-of-work model uses subpuzzles to normalise expected solving times but also to scale problem difficulties. To 

The difference to hashcash is that RB-PoW uses SHA2 in place of SHA1, since it is a cryptographically stronger hash. 


The following sections will present server-side metrics needed to define client behaviour and explain assumptions made for a target application. 
We will precisely define the meaning of client behaviour in our model and finally carry on to develop and describe the reputation based proof-of-work model.

\input{metrics}
\input{atk_model}
\subsection{Behaviour model}\label{tab:behaviourmodel}
In the context of our reputation system, behaviour is defined as the measured time between requests sent to the server. Furthermore, both historical data and close to real-time data are taken into account by the use of a rolling average. However, there is two fundamental differences in the way that global behaviour is computed in comparison to the individual behaviour of a client. The first and most important difference is that the individual client behaviour is rated based on it's own frequency of requests, while the global behaviour is based on the frequency between the requests of all clients. 

A perhaps a more subtle difference is how much weight the historical behaviour should have. The weight of historical behaviour impacts the rate of change. Thus a higher weight gives a more stable and slower moving measurement of the behaviour. Hence, more fitting for the defining the general behaviour of clients on the server. While a lower weight tend to be closer to real-time measurement thus befitting the individual behaviour of a client.

\subsection{Reputation Mechanism as a Difficulty Scaler}
We propose a conceptually simple yet in practice effective reputation system. A client is rated based on historical and current behaviour. The reputation mechanism distributes proof of work problems with a difficulty dependant on the individual client behaviour compared to the global average behaviour as well as server load. 

The basic idea of the RB-PoW scheme is that the server is dimensioned to handle normal load. If the server load is beneath \emph{cpu\_thres}, the server is in a normal state and no PoW scheme needs to be applied. If server load is above {\em cpu\_thres}, PoW may be activated, suspecting all clients as possible adversaries [SOURCE HÄR]. Another foundation of the RB-PoW model is an assumption that legitimate clients utlises a lower request rate than a malicious user. so if the server is under attack we compare the behaviour ( access time ) of the client against global average. If extremely favourable, client may get a free ticket to the zoo, and if extremely taxing on the server client gets an extremely hard problem.  ;)
