The architecture of the testing framework may be described in terms of data flow (protocol) and control flow (software). On the following pages both data flow and control flow of the application will be thoroughly explained.

\subsection{Protocol}

\subsubsection{Protocol notation}
To formalize the Proof of Work protocol a few notations will be introduced. Consider the following notations:
\\
\\
\indent \begin{minipage}{0.9\linewidth}
\thickmuskip=0mu
${\textbf M_i} \ = $ to be $i^{th}$ execution of the protocol $M$ by either a legitimate user or an adversary. 

${\textbf g} \ = $ a puzzle generator function.

${\textbf t} \ = $ timestamp at time of puzzle generation

${\textbf P[j]} \ = $ the $j^{th}$ sub-puzzle in $P$.

${\textbf m} \ = $ the number of sub-puzzles, this equals to the size of the set $P$. 

${\textbf d} \ = $ an integer indicating the difficulty of the problem set $P$. 

${\textbf S[j]} \ = $ the $j^{th}$ solution in $S$ and a solution to $j^{th}$ sub-puzzle in $P$. 

${\textbf b_j} \ = $ the number of bytes in solution $S[j]$ that is zero. 
\vspace*{-10pt}
\end{minipage}

\subsubsection{Protocol description}
 Now let us describe the details of our proposed reputation based puzzle protocol between client and server. Prior to initiating protocol \textbf{M} the client $C_i$ starts by requesting for a service $R_i$ to the server. The server responds with a packaged set of sub-puzzles $P_i$ of size $m$ and a difficutly $d$. Each sub-puzzle $P[1] \dots P[m]$ is a seed derived by $g(t,x)$ where $x$ is value generated uniformly-at-random.

 The client $C_i$ must solve each sub-puzzle $P[j]$ of $P_i$ by finding the value $S[j]$, such that the concatination of the bytestrings $S[j]$ and $P[j]$ generates a hash where $b_j$ is equal to $d$. The server then verifies each solution of $S$ by generating hash with a stored copy of $P$ and confirms that $b_j$ is equal to $d$. If all solutions are correctly computed by $C_i$ the request $R_i$ will be granted. 

\begin{figure}
	\begin{center}
		\begin{tikzpicture}

		\scriptsize
		\matrix (m)[matrix of nodes, column  sep=-15mm,row  sep=1.5mm, nodes={draw=none, anchor=center,text depth=0pt} ]{
		\textbf{\normalsize server} & & \textbf{\hspace*{20pt}\normalsize client}\\[0mm]
		& & \\
		& Initialisation of protocol \textbf{M}& \\
		& service request $R_i$& \\
		generate sub-puzzles \\
		$P[j] := g(t,x), 1\leq j \leq m$\\
		$P_i :=$ $\{P[1 \dots m],d\}$ \hfill \\
		& send puzzles & \\
		& & solve each $P[j] \in P$ \\
		& & $S_i := \{S[1 \dots m]\}$ \\
		& send solutions & \\
		verify each $S[j] \in S$ && \\ 
		& grant request $R_i$ & \\
		};
		\draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-4-2.south east)--(m-4-2.south west);
		\draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-8-2.south west)--(m-8-2.south east);
		\draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-11-2.south east)--(m-11-2.south west);
		\draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-13-2.south west)--(m-13-2.south east);
		\end{tikzpicture}
		 \vspace{10pt}
		\caption{Diagram of Proof of Work protocol}\label{tab:protocol}
	 \end{center}
\end{figure}


  If the reputation system deems the server to not being under attack i.e. under normal server operation this problem package will be the empty set, indicating that no puzzles are being distributed. Hence, the client will ''solve'' this empty set with no effort and then respond back to the server.\footnote{This is a design decision that can be questioned. Some might say that the handshaking process with empty sets could bring unneccesary load on the server. However, empty sets will only be distributed when pressure on the server is low thus the extra verification can be afforded.} The server will then verify the solution for $P_i$ and grant access to $R_i$ of protocol \textbf{M}.

\\
If the reputation system deems the server to be under attack the difficulty of the problem set of request $R_i$ will be decided by the historical and current behaviour of client $C_i$. 


The client behaviour can generally be divided into three cases:
\begin{itemize}
\item the client $C_i$ behaves in a comparable manner to the general behaviour of all users and the request $R_i$ is responded with a problem difficulty suitable to server load.
\item the client $C_i$ requests lesser resources compared to the general behaviour and the request $R_i$ is responded with a problem difficulty easier than the general difficulty.
\item the client $C_i$ requests more resources compared to the general behaviour and the request $R_i$ is responded with a problem difficulty harder than the general difficulty.
\end{itemize}

To prevent an attacker from reusing solutions for multiple requests the problem set $\phi_i$ is chosen by the server and stored in memory.
[lite mer information om generering av problem. Varje problem är relativt unikt för varje request osv]


\subsection{Software}
Since one requirement on our Proof of Work system is that it minimises differences between a wide variety of devices; it needs to support both desktop and laptops with different operating systems as well as cellphones and tablets.
In order to minimise the development effort and maximise maintainability of the code base, a multi platform solution was sought for the client part of the demo application. 

A web based solution makes the application portable, but the web is not inherently stateful nor does emulate a general service greatly. However, the advent of websockets enables a truly multi-platform PoW client in html and javascript while maintaining the generality and plasticity of a natively written socket based application. 
\begin{comment}
The javascript implementation for handling the protocol is quite simple:
\jscode[firstline=57, firstnumber=57, lastline=84]{../pow.js}
The solution finding part also need to be presented:
\jscode[firstline=26, firstnumber=26, lastline=49]{../pow.js}
To trigger a request to be sent to the server we build the following function which is then registered to the onclick event of a button in the web gui:
\jscode[firstline=100, firstnumber=100, lastline=105]{../pow.js}
\end{comment}

The server side was implemented in Google's novel programming language go\cite{golang}. The real strengths of golang in this context is actually not performance nor simplicity\footnote{But the expressiveness, clarity and performance of go programs is not to be dismissed.} but rather it's standard libraries, which in other contexts may appear immature. Golang actually has standard libraries for both html template generation, http web serving as well as websockets. This package makes for an ideal platform for an application that needs to deliver the client application\footnote{HTML, CSS, Javascript and all that magic that make stuff happen in the browser} to potential clients as well as servicing clients requests in the model application reachable through the websocket interface. 

Communication is performed over a websocket per client, with a single message type which is (de-)serialised to (from) JSON. JSON is natively supported in the Javascript client, and the golang websocket library supports JSON (de-)serialisation. Thus no byte parsing of specific to our protocol had to be produced.
\gocode[firstline=35, firstnumber=35, lastline=40]{../conn.go}
\\
The client application is initiated by visiting the servers webpage, thus downloading the client\footnote{The client application is built in javascript which is distributed to the computer that shall run the client via a webpage}. If the client wants the server to perform its service it will submit a request with operation code $0$, which means that the client is requesting a problem to solve in order to aquire the servers trust. The server will respond with a set of problems and an operation code $1$, telling the client to solve the problem set. The client will solve the problems and submit the solutions with an operation code $1$ and submit it to the server. The client needs to use a bruteforce approach since no better algorithm is known (this is on purpose):
\jscode[firstline=26, firstnumber=26, lastline=49]{../pow.js}
The server will check that the solution is correct with considerable less effort:
\gocode[firstline=143, firstnumber=143, lastline=159]{../problem.go}
If the server accepts the solution, it offers the client some meaningless cpu cycles in order to simulate a request:
\gocode[firstline=95, firstnumber=95, lastline=97]{../conn.go}





%\subsection{Reputation System}

